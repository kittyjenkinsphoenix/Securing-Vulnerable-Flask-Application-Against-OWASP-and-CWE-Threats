import traceback
from flask import request, render_template, redirect, url_for, session, Blueprint, flash, abort
from flask_login import current_user, login_user, logout_user, login_required
from flask import current_app
from functools import wraps
from sqlalchemy import text
from sqlalchemy.exc import IntegrityError
from urllib.parse import urlparse
import bleach
import logging
from werkzeug.security import check_password_hash
from app import db
from datetime import datetime, timedelta, timezone
from app.models import User
from app import logging
from app.forms import RegistrationForm, LoginForm, ChangePasswordForm

main = Blueprint("main", __name__)

def role_required(role):
    def decorator(f):
        @wraps(f)
        @login_required
        def wrapped(*args, **kwargs):
            allowed = [role] if isinstance(role, str) else list(role) # Generated By Copilot
            user_role = getattr(current_user, 'role', None) # Generated By Copilot
            if user_role not in allowed: 
                stack = ''.join(traceback.format_stack(limit=25)) # Generated By Copilot
                current_app.logger.warning("Unauthorized access attempt user=%s role=%s path=%s", getattr(current_user, 'id', None), user_role, request.path) # Generated By Copilot
                abort(403, description=f"Access denied.\n\n--- STACK (demo) ---\n{stack}")
            return f(*args, **kwargs)
        return wrapped
    return decorator

@main.route("/")
def home():
    return render_template("home.html")

@main.route("/login", methods=["GET", "POST"])
def login():
    if current_user.is_authenticated:
        return redirect(url_for("main.home"))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash("Invalid Username Or Password", "error")
            current_app.logger.warning("Failed login for email=%s from %s", form.username.data, request.remote_addr)
            return redirect(url_for("main.login"))

        session.clear()
        login_user(user)
        current_app.logger.info("Login success for user_id=%s from %s", user.id, request.remote_addr)
        
        next_page = request.args.get("next")
        if not next_page or urlparse(next_page).netloc != '':
            next_page = url_for("main.home")
        return redirect(next_page)

    return render_template("login.html", title="Sign In", form=form)

@main.route("/logout")
def logout():
    logout_user()
    return redirect(url_for("main.login"))

@main.route("/dashboard")
@login_required
def dashboard():
    if "user" in session:
        username = session["user"]
        bio = session["bio"]
        return render_template("dashboard.html", username=username, bio=bio)
    return redirect(url_for("main.login"))

@main.route("/register", methods=["GET", "POST"])
def register():
    if current_user.is_authenticated:
        return redirect(url_for("main.home"))

    form = RegistrationForm()
    if form.validate_on_submit():
        allowed_tags = ["b", "i", "u", "em", "strong", "a", "p", "ul", "ol", "li", "br"]
        allowed_attrs = {"a": ["href", "title"]}
        clean_bio = bleach.clean(form.bio.data or "", tags=allowed_tags, attributes=allowed_attrs)

        # The application uses the username column to store the user's email address
        user = User(username=form.email.data, password=form.password.data, role='user', bio=clean_bio)
        db.session.add(user)
        try:
            db.session.commit()
        except IntegrityError:
            db.session.rollback()
            flash("Email Already Exists. Please Choose A Different One.", "error")
            return redirect(url_for("main.register"))

        flash("Congratulations, You Are Now A Registered User!", "Success")
        return redirect(url_for("main.login"))

    return render_template("register.html", form=form)

@main.route("/admin-panel")
@role_required("admin")
def admin():
    return render_template("admin.html")

@main.route('/moderator')
@role_required("moderator")
def moderator():
    return render_template("moderator.html")

@main.route("/user-dashboard")
@role_required("user")
def user_dashboard():
    return render_template("user_dashboard.html", username=current_user.username)

@main.route("/change-password", methods=["GET", "POST"])
@login_required
def change_password():
    form = ChangePasswordForm()
    if form.validate_on_submit():
        currentPassword = form.oldPassword.data 
        newPassword = form.newPassword.data 

        if not current_user.check_password(currentPassword): # Generated By Copilot
            try:
                user_id = current_user.get_id() if getattr(current_user, 'is_authenticated', False) else 'anonymous'
                current_app.logger.warning("Failed Password Re-authentication For User=%s From %s", user_id, request.remote_addr)
            except Exception:
                current_app.logger.warning("Failed Password Re-authentication For Unknown User")
            flash("Unable To Change Password", "error")
            return render_template("change_password.html", form=form)

        if current_user.check_password(newPassword):
            flash("Unable To Change Password", "error")
            return render_template("change_password.html", form=form)

        current_user.set_password(newPassword)
        db.session.commit()

        flash("Password Changed Successfully", "Success")
        current_app.logger.info("Password changed for user_id=%s from %s", current_user.get_id(), request.remote_addr)
        return redirect(url_for("main.user_dashboard"))

    return render_template("change_password.html", form=form)

@main.before_app_request
def check_idle_timeout():
    now = datetime.now(timezone.utc)
    last_activity = session.get("last_activity", now) 
    if now - last_activity > timedelta(minutes=15):
        session.clear()
        return redirect(url_for("main.login"))
    session["last_activity"] = now

@main.errorhandler(400)
def bad_request(error):
    return render_template('400.html', error=error), 400

@main.errorhandler(403)
def forbidden(error):
    return render_template('403.html', error=error), 403

@main.errorhandler(404)
def not_found(error):
    return render_template('404.html', error=error), 404

@main.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('500.html', error=error), 500